# Edge Fullstack Starter - AI Coding Rules

## ðŸŽ¯ Project Overview

This is an **edge-first fullstack template** that runs on multiple runtimes:
- Cloudflare Workers
- Vercel Edge Functions
- Deno Deploy
- Node.js

**Core Philosophy**: Write once, deploy anywhere using Web Standards.

---

## ðŸš« Critical Constraints

### Edge Compatibility Rules

#### âŒ FORBIDDEN in `src/server/`:
```typescript
// Node.js built-ins
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { Buffer } from 'buffer';

// Native modules
import bcrypt from 'bcrypt';
import sqlite3 from 'better-sqlite3';

// Node.js APIs
process.env.NODE_ENV;
__dirname;
__filename;
```

#### âœ… ALLOWED in `src/server/`:
```typescript
// Web Standard APIs
crypto.randomUUID();
crypto.subtle.digest();
fetch('https://api.example.com');
new Request();
new Response();
new URL();
new Headers();

// Platform-agnostic libraries
import { Hono } from 'hono';
import { z } from 'zod';
import { drizzle } from 'drizzle-orm';

// Environment via Hono context
c.env.DATABASE_URL;
```

---

## ðŸ“ Project Structure

```
src/
â”œâ”€â”€ server/          # Backend API (EDGE-COMPATIBLE ONLY)
â”‚   â”œâ”€â”€ index.ts     # Hono app entry point
â”‚   â””â”€â”€ routes/      # API route handlers
â”œâ”€â”€ client/          # React frontend (browser APIs only)
â”‚   â”œâ”€â”€ pages/       # Page components
â”‚   â”œâ”€â”€ main.tsx     # React entry point
â”‚   â””â”€â”€ index.css    # Global styles
â”œâ”€â”€ adapters/        # Runtime-specific entry points
â”‚   â”œâ”€â”€ cloudflare/  # Cloudflare Workers adapter
â”‚   â”œâ”€â”€ vercel/      # Vercel Edge adapter
â”‚   â”œâ”€â”€ deno/        # Deno Deploy adapter
â”‚   â””â”€â”€ node/        # Node.js adapter (can use Node APIs)
â””â”€â”€ shared/          # Type contracts (platform-agnostic)
```

**Rule**: If it's in `src/server/`, it MUST work in Cloudflare Workers.

---

## âœ… Standard Workflows

### Adding a New API Route

**Step 1**: Create route handler in `src/server/routes/`

```typescript
// src/server/routes/items.ts
import { Hono } from 'hono';
import { z } from 'zod';

const items = new Hono();

// Define Zod schema
const itemSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  createdAt: z.string().datetime(),
});

// GET /api/items
items.get('/', async (c) => {
  // Get database from context (injected by middleware)
  const db = c.get('db');
  const results = await db.select().from(itemsTable).all();
  return c.json(results);
});

// POST /api/items
items.post('/', async (c) => {
  try {
    const body = await c.req.json();
    const validated = itemSchema.omit({ id: true, createdAt: true }).parse(body);
    
    const newItem = {
      id: crypto.randomUUID(),
      ...validated,
      createdAt: new Date().toISOString(),
    };
    
    const db = c.get('db');
    await db.insert(itemsTable).values(newItem);
    
    return c.json(newItem, 201);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return c.json({ error: 'Validation failed', details: error.errors }, 400);
    }
    return c.json({ error: 'Internal server error' }, 500);
  }
});

export default items;
```

**Step 2**: Register route in `src/server/index.ts`

```typescript
import items from './routes/items';

app.route('/api/items', items);
```

**Step 3**: Create React page in `src/client/pages/`

```typescript
// src/client/pages/ItemsPage.tsx
import { useState, useEffect } from 'react';

interface Item {
  id: string;
  name: string;
  createdAt: string;
}

export default function ItemsPage() {
  const [items, setItems] = useState<Item[]>([]);
  
  useEffect(() => {
    fetch('/api/items')
      .then(res => res.json())
      .then(data => setItems(data));
  }, []);
  
  return (
    <div>
      <h1>Items</h1>
      {items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

**Step 4**: Add route to `src/client/App.tsx`

```typescript
import ItemsPage from './pages/ItemsPage';

<Route path="/items" element={<ItemsPage />} />
```

---

## ðŸŽ¨ Code Style

### TypeScript
- **Strict mode** - No `any` types
- **Zod validation** - Validate all API inputs
- **Type inference** - Use `z.infer<typeof schema>`

### File Naming
- **Components**: PascalCase (`ItemsPage.tsx`)
- **Routes**: kebab-case (`user-profile.ts`)
- **Utilities**: camelCase (`formatDate.ts`)

### Error Handling
```typescript
// âœ… Always use try-catch with proper status codes
try {
  const validated = schema.parse(data);
  // ... business logic
  return c.json(result, 201);
} catch (error) {
  if (error instanceof z.ZodError) {
    return c.json({ error: 'Validation failed', details: error.errors }, 400);
  }
  console.error('Unexpected error:', error);
  return c.json({ error: 'Internal server error' }, 500);
}
```

---

## ðŸš¨ Red Flags

Stop and review if you see:

ðŸš© Importing Node.js built-ins in `src/server/`
ðŸš© Using `process.env` in `src/server/` (use `c.env` instead)
ðŸš© Using `__dirname` or `__filename` in `src/server/`
ðŸš© Missing Zod validation on API inputs
ðŸš© Hardcoded environment values
ðŸš© Direct database imports (should use context injection)

---

## ðŸ§ª Testing Checklist

Before committing:
- [ ] TypeScript check passes (`npm run type-check`)
- [ ] Linting passes (`npm run lint`)
- [ ] Dev server runs (`npm run dev`)
- [ ] All API routes return proper status codes
- [ ] All inputs validated with Zod
- [ ] No Node.js APIs in `src/server/`
- [ ] Environment variables accessed via `c.env`

---

## ðŸ“š Tech Stack Reference

### Backend
- **Hono** - Web framework (edge-compatible)
- **Drizzle ORM** - Type-safe database queries
- **Zod** - Runtime validation
- **SQLite** - Dev database (via better-sqlite3 in dev server only)

### Frontend
- **React 18** - UI library
- **React Router** - Client-side routing
- **Vite** - Build tool and dev server
- **Tailwind CSS** - Utility-first styling

### Deployment
- **Cloudflare Workers** - Edge runtime
- **Vercel Edge Functions** - Edge runtime
- **Deno Deploy** - Edge runtime
- **Node.js** - Traditional runtime

---

## ðŸ’¡ Pro Tips

1. **Start with types** - Define Zod schemas before writing handlers
2. **Validate everything** - Use Zod on all API inputs
3. **Think edge-first** - If it doesn't work in Workers, it's not edge-compatible
4. **Inject dependencies** - Use Hono context for database, env vars, etc.
5. **Use Web Standards** - Stick to APIs available in browsers

---

## ðŸ”— Quick Links

- [Hono Documentation](https://hono.dev/)
- [Drizzle ORM](https://orm.drizzle.team/)
- [Zod Documentation](https://zod.dev/)
- [React Documentation](https://react.dev/)
- [Vite Documentation](https://vitejs.dev/)
- [Tailwind CSS](https://tailwindcss.com/)

---

**Remember**: This template is designed to run anywhere. Keep it edge-compatible!
